//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

    export interface IAccountClient {
        /**
         * Async Authenticate
         * @param request AuthenticationRequest
         */
        authenticate(request: AuthenticationRequest): Promise<FileResponse | null>;
        /**
         * Async Register
         * @param request RegisterRequest
         */
        register(request: RegisterRequest): Promise<FileResponse | null>;
        /**
         * Async Confirm email
         * @param userId (optional) String
         * @param password (optional) String
         */
        confirmEmail(userId: string | null | undefined, password: string | null | undefined): Promise<FileResponse | null>;
        /**
         * Async Forgot password
         * @param request ForgotPasswordRequest
         */
        forgotPassword(request: ForgotPasswordRequest): Promise<FileResponse | null>;
        /**
         * Async Reset password
         * @param request ResetPasswordRequest
         */
        resetPassword(request: ResetPasswordRequest): Promise<FileResponse | null>;
        /**
         * Async Refresh token
         * @param request RefreshTokenRequest
         */
        refreshToken(request: RefreshTokenRequest): Promise<FileResponse | null>;
        /**
         * Async Logout
         * @param userEmail (optional) string
         */
        logout(userEmail: string | null | undefined): Promise<FileResponse | null>;
    }

    export class AccountClient implements IAccountClient {
        private instance: AxiosInstance;
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, instance?: AxiosInstance) {

            this.instance = instance ? instance : axios.create();

            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44372";

        }

        /**
         * Async Authenticate
         * @param request AuthenticationRequest
         */
        authenticate(request: AuthenticationRequest, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Authenticate";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processAuthenticate(_response);
            });
        }

        protected processAuthenticate(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Register
         * @param request RegisterRequest
         */
        register(request: RegisterRequest, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Register";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processRegister(_response);
            });
        }

        protected processRegister(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Confirm email
         * @param userId (optional) String
         * @param password (optional) String
         */
        confirmEmail(userId: string | null | undefined, password: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Confirm-Email?";
            if (userId !== undefined && userId !== null)
                url_ += "userId=" + encodeURIComponent("" + userId) + "&";
            if (password !== undefined && password !== null)
                url_ += "password=" + encodeURIComponent("" + password) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_: AxiosRequestConfig = {
                responseType: "blob",
                method: "GET",
                url: url_,
                headers: {
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processConfirmEmail(_response);
            });
        }

        protected processConfirmEmail(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Forgot password
         * @param request ForgotPasswordRequest
         */
        forgotPassword(request: ForgotPasswordRequest, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Forgot-Password";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processForgotPassword(_response);
            });
        }

        protected processForgotPassword(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Reset password
         * @param request ResetPasswordRequest
         */
        resetPassword(request: ResetPasswordRequest, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/reset-password";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processResetPassword(_response);
            });
        }

        protected processResetPassword(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Refresh token
         * @param request RefreshTokenRequest
         */
        refreshToken(request: RefreshTokenRequest, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Refreshtoken";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processRefreshToken(_response);
            });
        }

        protected processRefreshToken(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        /**
         * Async Logout
         * @param userEmail (optional) string
         */
        logout(userEmail: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Account/Logout?";
            if (userEmail !== undefined && userEmail !== null)
                url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_: AxiosRequestConfig = {
                responseType: "blob",
                method: "GET",
                url: url_,
                headers: {
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processLogout(_response);
            });
        }

        protected processLogout(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }
    }

    export interface IAdminClient {
        getAllUser(): Promise<FileResponse | null>;
        getAllUserWithRoles(): Promise<FileResponse | null>;
    }

    export class AdminClient implements IAdminClient {
        private instance: AxiosInstance;
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, instance?: AxiosInstance) {

            this.instance = instance ? instance : axios.create();

            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44372";

        }

        getAllUser(cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Admin/alluser";
            url_ = url_.replace(/[?&]$/, "");

            let options_: AxiosRequestConfig = {
                responseType: "blob",
                method: "GET",
                url: url_,
                headers: {
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processGetAllUser(_response);
            });
        }

        protected processGetAllUser(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }

        getAllUserWithRoles(cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Admin/alluserwithroles";
            url_ = url_.replace(/[?&]$/, "");

            let options_: AxiosRequestConfig = {
                responseType: "blob",
                method: "GET",
                url: url_,
                headers: {
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processGetAllUserWithRoles(_response);
            });
        }

        protected processGetAllUserWithRoles(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }
    }

    export interface IGraphQLClient {
        post(query: GraphQLQuery): Promise<FileResponse | null>;
    }

    export class GraphQLClient implements IGraphQLClient {
        private instance: AxiosInstance;
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, instance?: AxiosInstance) {

            this.instance = instance ? instance : axios.create();

            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44372";

        }

        post(query: GraphQLQuery, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/GraphQL";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(query);

            let options_: AxiosRequestConfig = {
                data: content_,
                responseType: "blob",
                method: "POST",
                url: url_,
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processPost(_response);
            });
        }

        protected processPost(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }
    }

    export interface ILogClient {
        /**
         * GetUserAuthLogs
         * @param email (optional) String
         * @return Success
         */
        getUserAuthLogs(email: string | null | undefined): Promise<FileResponse | null>;
    }

    export class LogClient implements ILogClient {
        private instance: AxiosInstance;
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, instance?: AxiosInstance) {

            this.instance = instance ? instance : axios.create();

            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44372";

        }

        /**
         * GetUserAuthLogs
         * @param email (optional) String
         * @return Success
         */
        getUserAuthLogs(email: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
            let url_ = this.baseUrl + "/api/Log/get?";
            if (email !== undefined && email !== null)
                url_ += "email=" + encodeURIComponent("" + email) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_: AxiosRequestConfig = {
                responseType: "blob",
                method: "GET",
                url: url_,
                headers: {
                    "Accept": "application/octet-stream"
                },
                cancelToken
            };

            return this.instance.request(options_).catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            }).then((_response: AxiosResponse) => {
                return this.processGetUserAuthLogs(_response);
            });
        }

        protected processGetUserAuthLogs(response: AxiosResponse): Promise<FileResponse | null> {
            const status = response.status;
            let _headers: any = {};
            if (response.headers && typeof response.headers === "object") {
                for (let k in response.headers) {
                    if (response.headers.hasOwnProperty(k)) {
                        _headers[k] = response.headers[k];
                    }
                }
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
                let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
                let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
                if (fileName) {
                    fileName = decodeURIComponent(fileName);
                } else {
                    fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                    fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                }
                return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<FileResponse | null>(null as any);
        }
    }

    export class AuthenticationRequest implements IAuthenticationRequest {
        email?: string | undefined;
        password?: string | undefined;

        constructor(data?: IAuthenticationRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.email = _data["email"];
                this.password = _data["password"];
            }
        }

        static fromJS(data: any): AuthenticationRequest {
            data = typeof data === 'object' ? data : {};
            let result = new AuthenticationRequest();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.email;
            data["password"] = this.password;
            return data;
        }
    }

    export interface IAuthenticationRequest {
        email?: string | undefined;
        password?: string | undefined;
    }

    export class RegisterRequest implements IRegisterRequest {
        userName!: string;
        firstName!: string;
        lastName!: string;
        email!: string;
        password!: string;
        confirmPassword!: string;

        constructor(data?: IRegisterRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.userName = _data["userName"];
                this.firstName = _data["firstName"];
                this.lastName = _data["lastName"];
                this.email = _data["email"];
                this.password = _data["password"];
                this.confirmPassword = _data["confirmPassword"];
            }
        }

        static fromJS(data: any): RegisterRequest {
            data = typeof data === 'object' ? data : {};
            let result = new RegisterRequest();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["userName"] = this.userName;
            data["firstName"] = this.firstName;
            data["lastName"] = this.lastName;
            data["email"] = this.email;
            data["password"] = this.password;
            data["confirmPassword"] = this.confirmPassword;
            return data;
        }
    }

    export interface IRegisterRequest {
        userName: string;
        firstName: string;
        lastName: string;
        email: string;
        password: string;
        confirmPassword: string;
    }

    export class ForgotPasswordRequest implements IForgotPasswordRequest {
        email!: string;

        constructor(data?: IForgotPasswordRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.email = _data["email"];
            }
        }

        static fromJS(data: any): ForgotPasswordRequest {
            data = typeof data === 'object' ? data : {};
            let result = new ForgotPasswordRequest();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.email;
            return data;
        }
    }

    export interface IForgotPasswordRequest {
        email: string;
    }

    export class ResetPasswordRequest implements IResetPasswordRequest {
        email!: string;
        token!: string;
        password!: string;
        confirmPassword!: string;

        constructor(data?: IResetPasswordRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.email = _data["email"];
                this.token = _data["token"];
                this.password = _data["password"];
                this.confirmPassword = _data["confirmPassword"];
            }
        }

        static fromJS(data: any): ResetPasswordRequest {
            data = typeof data === 'object' ? data : {};
            let result = new ResetPasswordRequest();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.email;
            data["token"] = this.token;
            data["password"] = this.password;
            data["confirmPassword"] = this.confirmPassword;
            return data;
        }
    }

    export interface IResetPasswordRequest {
        email: string;
        token: string;
        password: string;
        confirmPassword: string;
    }

    export class RefreshTokenRequest implements IRefreshTokenRequest {
        email?: string | undefined;
        token?: string | undefined;

        constructor(data?: IRefreshTokenRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.email = _data["email"];
                this.token = _data["token"];
            }
        }

        static fromJS(data: any): RefreshTokenRequest {
            data = typeof data === 'object' ? data : {};
            let result = new RefreshTokenRequest();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.email;
            data["token"] = this.token;
            return data;
        }
    }

    export interface IRefreshTokenRequest {
        email?: string | undefined;
        token?: string | undefined;
    }

    export class GraphQLQuery implements IGraphQLQuery {
        operationName?: string | undefined;
        namedQuery?: string | undefined;
        query?: string | undefined;
        variables?: any | undefined;

        constructor(data?: IGraphQLQuery) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(_data?: any) {
            if (_data) {
                this.operationName = _data["operationName"];
                this.namedQuery = _data["namedQuery"];
                this.query = _data["query"];
                this.variables = _data["variables"];
            }
        }

        static fromJS(data: any): GraphQLQuery {
            data = typeof data === 'object' ? data : {};
            let result = new GraphQLQuery();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["operationName"] = this.operationName;
            data["namedQuery"] = this.namedQuery;
            data["query"] = this.query;
            data["variables"] = this.variables;
            return data;
        }
    }

    export interface IGraphQLQuery {
        operationName?: string | undefined;
        namedQuery?: string | undefined;
        query?: string | undefined;
        variables?: any | undefined;
    }

    export interface FileResponse {
        data: Blob;
        status: number;
        fileName?: string;
        headers?: { [name: string]: any };
    }

    export class ApiException extends Error {
        message: string;
        status: number;
        response: string;
        headers: { [key: string]: any; };
        result: any;

        constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
            super();

            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }

        protected isApiException = true;

        static isApiException(obj: any): obj is ApiException {
            return obj.isApiException === true;
        }
    }

    function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new ApiException(message, status, response, headers, null);
    }

    function isAxiosError(obj: any | undefined): obj is AxiosError {
        return obj && obj.isAxiosError === true;
    }
